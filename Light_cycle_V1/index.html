<!DOCTYPE html>
<html>
<head>
    <title>Tron V1</title>
</head>
<body>
    <div id="score">0</div>
    <canvas id="The_Grid" width="300" height="300" style="border:3px solid #686868;">
    </canvas>
    <script>
            //Global varibles

           var c = document.getElementById("The_Grid");
           var ctx = c.getContext("2d"); 

           //initalizes the values for dx and dy
            dx = 0
            dy = -5

            //intializes ai start movement vals
            ai_dx = 0
            ai_dy = 5

            const AI_TURN_DELAY = 0;
            let ai_turnCooldown = 0;

            // Creates the solid background colour
            ctx.fillStyle = "#020225"
            ctx.fillRect(0,0,300,300);

            /*
            The funtion drawGrid will create the background grid for the gamespace
            Creates evenly spaced lines creating a grid like effect
            */
           function drawGrid(){
                ctx.beginPath();
                for(let x = 0; x <= 300; x += 30) {
                    ctx.moveTo(x,0);
                    ctx.lineTo(x,300);
                    ctx.strokeStyle = "black";
                    ctx.lineWidth = 3;
                }
                ctx.stroke();

                ctx.beginPath();
                for(let y = 0; y <= 300; y += 30) {
                    ctx.moveTo(0,y);
                    ctx.lineTo(300,y);
                    ctx.strokeStyle = "black";
                    ctx.lineWidth = 3;
                }
                ctx.stroke();
           }
           drawGrid(); //draws the grid before anything happens


           let snake = [  {x: 150, y: 270},  {x: 150, y: 275},  {x: 150, y: 280},  {x: 150, y: 285},  {x: 150, y: 290},]; //starting location of the players cycle
           let Ai_cycle = [  {x: 150, y: 30},  {x: 150, y: 25},  {x: 150, y: 20},  {x: 150, y: 15},  {x: 150, y: 10},]; // starting location of Ai cycle
           /*
           The funtion drawSnakePart will draw one segment of the snake given the cooradinates of the part
           @param {x-coordinate, y-coordinate}
           */
           function drawSnakePart(snakePart){
                ctx.fillStyle = 'blue'; 
                ctx.strokeStyle ='black';
                ctx.lineWidth = 2;
                ctx.fillRect(snakePart.x,snakePart.y, 5, 5); 
                ctx.strokeRect(snakePart.x, snakePart.y,5, 5);}

             /*
           The funtion draw_AI_cyclePart will draw one segment of the ai cycle given the cooradinates of the part
           @param {x-coordinate, y-coordinate}
           */
           function draw_AI_cyclePart(snakePart){
                ctx.fillStyle = 'orange'; 
                ctx.strokeStyle ='black';
                ctx.lineWidth = 2;
                ctx.fillRect(snakePart.x,snakePart.y, 5, 5); 
                ctx.strokeRect(snakePart.x, snakePart.y,5, 5);}

            /*
            calls drawSnakePart to draw out each part of the snake we preloaded above
            */
           function drawSnake()  {snake.forEach(drawSnakePart);}
           /*
            calls drawSnakePart to draw out each part of the snake we preloaded above
            */
           function draw_AI_cycle()  {Ai_cycle.forEach(draw_AI_cyclePart);}
        
            /*
            Advances the snake by adding a new head which moves it forward
            */
           function advanceSnake() { 
                const head = {x: snake[0].x + dx, y:snake[0].y +dy};
                snake.unshift(head);
            }


            /*
            Clears the entire canvas and redraws the entire background, grid lines, and boarder lines
            */
            function clearCanvas() {
                ctx.fillStyle = "#020225";
                ctx.strokeStyle = "black";
                ctx.fillRect(0, 0, The_Grid.width, The_Grid.height);
                ctx.strokeRect(0, 0, The_Grid.width, The_Grid.height);
                drawGrid();
            }

            /*
            The main game loop - advances the snake, checks for collision(ends game if so), redraws the snake and continues the loop 
            */
            function main(){setTimeout(function onTick(){
                aiMovement();

                if (ai_turnCooldown > 0) ai_turnCooldown--;

                advanceAI();
                advanceSnake();

                if(did_Ai_collide(Ai_cycle[0].x, Ai_cycle[0].y)){
                    score += 10; document.getElementById('score').innerHTML = score;
                    alert("You Win!")
                return;
                }

                if(didGameEnd()){ 
                alert("Game Over!")
                return;
                 }

                
                draw_AI_cycle();
                drawSnake(); 
                main();  

                }, 65);
            };


            /*
            The funtion changeDirection takes in an input from the users arrow keys and move the snake accordingly
            Does not allow the user to move back into themselves
            */
            function changeDirection(event){ 
                const LEFT_KEY = 37; 
                const RIGHT_KEY = 39; 
                const UP_KEY = 38; 
                const DOWN_KEY = 40; 
                const keyPressed = event.keyCode;
                const goingUp = dy === -5;
                const goingDown = dy === 5;
                const goingRight = dx === 5;
                const goingLeft = dx === -5;
                if (keyPressed === UP_KEY && !goingDown){ dx = 0; dy = -5; };
                if (keyPressed === DOWN_KEY && !goingUp){ dx = 0; dy = 5; };
                if (keyPressed === RIGHT_KEY && !goingLeft){ dx = 5; dy = 0; };
                if (keyPressed === LEFT_KEY && !goingRight){ dx = -5; dy = 0; };
            }

            function aiSetDir(dx, dy, startCooldown = true) {
                ai_dx = dx;
                ai_dy = dy;
                if (startCooldown) ai_turnCooldown = AI_TURN_DELAY;
                }

            //basic Ai movement
            function aiMovement(){
                const head = Ai_cycle[0];
                const back = {x: head.x - ai_dx, y: head.y - ai_dy};       //AI movements(up, down, left, right)
                const forward = {x: head.x + ai_dx, y: head.y + ai_dy};
                const right = {x: head.x - ai_dy, y: head.y + ai_dx};
                const left = {x: head.x + ai_dy, y: head.y - ai_dx};
                
                const forwardSafe = !did_Ai_collide(forward.x, forward.y);

                if (ai_turnCooldown > 0) {
                    if (forwardSafe) {
                        return;
                    } 
                    else {
                        const options = [];
                        if (!did_Ai_collide(left.x, left.y))  {options.push({ dx:  ai_dy, dy: -ai_dx })};
                        if (!did_Ai_collide(right.x, right.y)){options.push({ dx: -ai_dy, dy:  ai_dx })};
                        if (options.length === 0 && !did_Ai_collide(back.x,back.y)){options.push({ dx: -ai_dx, dy: -ai_dy });}
                        if (options.length > 0) {
                            const choice = options[Math.floor(Math.random() * options.length)];
                            aiSetDir(choice.dx, choice.dy, true); 
                        }
                    return;
                    }
                }

                if (Math.random() < 0.85 && !did_Ai_collide(forward.x, forward.y)){ 
                    //checks if forward is safe and keeps ai going that way with a 15% chance of changing direction automatically 
                }
                else{
                    const options = []; //ai options list
                    if (!did_Ai_collide(left.x, left.y))  options.push({dx:  ai_dy, dy: -ai_dx}); //if a certain direction is safe to go in it will be added to the options list
                    if (!did_Ai_collide(right.x, right.y)) options.push({dx: -ai_dy, dy:  ai_dx});
                    if (forwardSafe) options.push({dx: ai_dx, dy: ai_dy});

                    
                    if (options.length === 0 && !did_Ai_collide(back.x, back.y)) { //turns around if there is no safe options
                        options.push({dx: -ai_dx, dy: -ai_dy});
                    }

                    if (options.length > 0) {
                        const choice = options[Math.floor(Math.random() * options.length)]; //if there are safe options it will randomly pick a direction
                        const turned = (choice.dx !== ai_dx) || (choice.dy !== ai_dy)
                        aiSetDir(choice.dx,choice.dy, turned)
                    }
                }
            }

            //advances the AI cycle, same logic as advance snake for the user cycle
            function advanceAI() { 
                const head = {x: Ai_cycle[0].x + ai_dx, y: Ai_cycle[0].y + ai_dy};
                Ai_cycle.unshift(head);
            }

            let score = 0;

            //allows for the funtion changeDirection to work via the key pressed by user
            document.addEventListener("keydown", changeDirection);

            // Determine if the Ai cycle collides with players, walls, or itself
            function did_Ai_collide(x,y){
                for (let s = 0; s < snake.length; s++) {
                    if (snake[s].x === x && snake[s].y === y) 
                        return true; 
                }

                for(let i = 1; i < Ai_cycle.length; i++){   
                    if (Ai_cycle[i].x === x && Ai_cycle[i].y === y)
                        return true;
                }

                const hitLeftWall = x < 0;
                const hitRightWall = x > c.width -5; 
                const hitToptWall = y < 0;
                const hitBottomWall = y > c.height -5;
                return hitLeftWall ||hitRightWall ||hitToptWall ||hitBottomWall 
            }

            /*
            Ends the game if the user hits a boarder wall or their own trail
            */
            function didGameEnd(){
                for(let i = 1; i < snake.length; i++)
                {if (snake[i].x === snake[0].x && snake[i].y === snake[0].y)
                    return true;    
                }

                for (let j = 0; j < Ai_cycle.length; j++) {
                    if (Ai_cycle[j].x === snake[0].x && Ai_cycle[j].y === snake[0].y) 
                        return true;
                }

                if(did_Ai_collide(Ai_cycle[0].x, Ai_cycle[0].y) === true){
                    return true
                }


                const headX = snake[0].x;
                const headY = snake[0].y;
                const hitLeftWall = headX < 0;
                const hitRightWall = headX > c.width -5; 
                const hitToptWall = headY < 0;
                const hitBottomWall = headY > c.height -5;
                return hitLeftWall ||hitRightWall ||hitToptWall ||hitBottomWall
            }

            main();
            

    </script>
</body>
</html>
